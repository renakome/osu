name: Build Android (signed debug) and Release

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:

jobs:
  build-android:
    runs-on: windows-latest
    timeout-minutes: 60
    env:
      DOTNET_CLI_TELEMETRY_OPTOUT: 1
      API_CLIENT_ID: ${{ secrets.API_CLIENT_ID }}
      API_CLIENT_SECRET: ${{ secrets.API_CLIENT_SECRET }}

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Setup JDK 11
      uses: actions/setup-java@v4
      with:
        distribution: microsoft
        java-version: 11

    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: "8.0.x"

    - name: Install .NET Android workload
      run: dotnet workload install android

    - name: Verify API credentials
      shell: pwsh
      run: |
        $clientId = $env:API_CLIENT_ID
        $clientSecret = $env:API_CLIENT_SECRET

        if ($clientId) {
          Write-Host "API_CLIENT_ID: $($clientId.Substring(0, [Math]::Min(3, $clientId.Length)))***"
        } else {
          Write-Host "API_CLIENT_ID: not set"
        }

        if ($clientSecret) {
          Write-Host "API_CLIENT_SECRET: $($clientSecret.Substring(0, [Math]::Min(3, $clientSecret.Length)))***"
        } else {
          Write-Host "API_CLIENT_SECRET: not set"
        }

        if (-not $clientId -or -not $clientSecret) {
          Write-Host "❌ API credentials not set!"
          exit 1
        } else {
          Write-Host "✅ API credentials configured"
        }

    - name: Restore
      run: dotnet restore osu.Android\osu.Android.csproj

    - name: Verify build environment
      shell: pwsh
      run: |
        $clientId = $env:API_CLIENT_ID
        $clientSecret = $env:API_CLIENT_SECRET

        if ($clientId) {
          Write-Host "Build API_CLIENT_ID: $($clientId.Substring(0, [Math]::Min(3, $clientId.Length)))***"
        }
        if ($clientSecret) {
          Write-Host "Build API_CLIENT_SECRET: $($clientSecret.Substring(0, [Math]::Min(3, $clientSecret.Length)))***"
        }

    - name: Build Release (Android)
      run: dotnet build osu.Android\osu.Android.csproj -c Release
      env:
        API_CLIENT_ID: ${{ secrets.API_CLIENT_ID }}
        API_CLIENT_SECRET: ${{ secrets.API_CLIENT_SECRET }}

    - name: Find main APK
      id: find_apks
      shell: pwsh
      run: |
        Write-Host "Looking for main osu! lazer APK..."

        # Look specifically for the main APK in the expected location
        $mainApkPath = "osu.Android\bin\Release\net8.0-android\sh.ppy.osulazer.apk"

        if (Test-Path $mainApkPath) {
          Write-Host "Found main APK: $mainApkPath"
          $apkPaths = @($mainApkPath)
        } else {
          Write-Host "Main APK not found at expected location: $mainApkPath"
          Write-Host "Searching for any sh.ppy.osulazer.apk files..."
          $foundApks = Get-ChildItem -Path "*sh.ppy.osulazer.apk" -Recurse -File -ErrorAction SilentlyContinue

          if ($foundApks -and $foundApks.Count -gt 0) {
            $apkPaths = $foundApks | Where-Object { $_.Name -eq "sh.ppy.osulazer.apk" } | Select-Object -ExpandProperty FullName
            Write-Host "Found main APK(s):"
            $apkPaths | ForEach-Object { Write-Host "  $_" }
          } else {
            Write-Host "No sh.ppy.osulazer.apk found. Listing all APK files for debug:"
            Get-ChildItem -Path "*.apk" -Recurse -File -ErrorAction SilentlyContinue | Select-Object -First 10 | ForEach-Object { Write-Host "  $($_.FullName)" }
            exit 1
          }
        }

        "apk_path=$($apkPaths[0])" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

    - name: Prepare keystore
      shell: pwsh
      run: |
        # Use release keystore from secrets if available, else generate debug keystore
        $keystoreB64 = "${{ secrets.KEYSTORE_BASE64 }}"
        $keystorePassword = "${{ secrets.KEYSTORE_PASSWORD }}"
        $keyAlias = "${{ secrets.KEY_ALIAS }}"
        $keyPassword = "${{ secrets.KEY_PASSWORD }}"

        if ($keystoreB64) {
          Write-Host "Using release keystore from secrets"

          # Decode base64 safely to binary
          try {
            [System.IO.File]::WriteAllBytes("release.keystore", [System.Convert]::FromBase64String($keystoreB64))
            Write-Host "Decoded release.keystore (binary)"
          } catch {
            Write-Host "Safe base64 decode failed, falling back to certutil decode method"
            $keystoreB64 | Out-File -FilePath "release.b64" -Encoding ASCII
            certutil -decode "release.b64" "release.keystore" | Out-Null
          }

          # Try to list as JKS first
          $isJks = $false
          Write-Host "Inspecting keystore as JKS..."
          & keytool -list -v -keystore release.keystore -storepass $keystorePassword 2>&1 | Tee-Object -Variable out1 | Out-Null
          if ($LASTEXITCODE -eq 0) {
            $isJks = $true
            Write-Host "Keystore appears to be JKS"
            $finalKeystore = "release.keystore"
          } else {
            Write-Host "Not JKS, trying PKCS12..."
            & keytool -list -v -keystore release.keystore -storetype PKCS12 -storepass $keystorePassword 2>&1 | Tee-Object -Variable out2 | Out-Null
            if ($LASTEXITCODE -eq 0) {
              Write-Host "Keystore is PKCS12 - converting to JKS for signing tool compatibility..."
              & keytool -importkeystore -srckeystore release.keystore -srcstoretype PKCS12 -srcstorepass $keystorePassword -destkeystore release.jks -deststoretype JKS -deststorepass $keystorePassword -destkeypass $keyPassword -noprompt
              if ($LASTEXITCODE -ne 0) {
                Write-Host "Failed to convert PKCS12 -> JKS. keytool output:"
                $out2
                exit 1
              }
              $finalKeystore = "release.jks"
              Write-Host "Converted keystore to release.jks"
            } else {
              Write-Host "Keystore not recognized as JKS or PKCS12. keytool outputs:"
              Write-Host $out1
              Write-Host $out2
              exit 1
            }
          }

          # Create keystore.properties for uber-apk-signer
          "storeFile=$finalKeystore" | Out-File -FilePath "keystore.properties" -Encoding ASCII
          "storePassword=$keystorePassword" | Out-File -FilePath "keystore.properties" -Append -Encoding ASCII
          "keyAlias=$keyAlias" | Out-File -FilePath "keystore.properties" -Append -Encoding ASCII
          "keyPassword=$keyPassword" | Out-File -FilePath "keystore.properties" -Append -Encoding ASCII
          Write-Host "Keystore configured: $finalKeystore"
        } else {
          Write-Host "No release keystore found in secrets, generating debug keystore"
          keytool -genkeypair -v -keystore debug.keystore -storepass android -keypass android -alias androiddebugkey -dname "CN=Android Debug,O=Android,C=US" -keyalg RSA -keysize 2048 -validity 10000
          "storeFile=debug.keystore" | Out-File -FilePath "keystore.properties" -Encoding ASCII
          "storePassword=android" | Out-File -FilePath "keystore.properties" -Append -Encoding ASCII
          "keyAlias=androiddebugkey" | Out-File -FilePath "keystore.properties" -Append -Encoding ASCII
          "keyPassword=android" | Out-File -FilePath "keystore.properties" -Append -Encoding ASCII
          Write-Host "Debug keystore configured"
        }

    - name: Download uber-apk-signer
      shell: pwsh
      run: |
        Invoke-WebRequest -Uri "https://github.com/patrickfav/uber-apk-signer/releases/download/v1.2.1/uber-apk-signer-1.2.1.jar" -OutFile "uber-apk-signer.jar"

    - name: Sign APK
      shell: pwsh
      run: |
        $apkPath = "${{ steps.find_apks.outputs.apk_path }}"
        Write-Host "Signing APK: $apkPath"

        # Read keystore config
        $keystoreConfig = Get-Content "keystore.properties"
        $storeFile = ($keystoreConfig | Where-Object { $_ -match "storeFile=" }) -replace "storeFile=", ""
        $storePass = ($keystoreConfig | Where-Object { $_ -match "storePassword=" }) -replace "storePassword=", ""
        $keyAlias = ($keystoreConfig | Where-Object { $_ -match "keyAlias=" }) -replace "keyAlias=", ""
        $keyPass = ($keystoreConfig | Where-Object { $_ -match "keyPassword=" }) -replace "keyPassword=", ""

        Write-Host "Using keystore: $storeFile"
        Write-Host "Listing keystore to verify alias exists..."
        & keytool -list -keystore $storeFile -storepass $storePass | Out-Host

        # Sign the APK using uber-apk-signer
        & java -jar uber-apk-signer.jar --apks "$apkPath" --ks "$storeFile" --ksAlias "$keyAlias" --ksPass "pass:$storePass" --ksKeyPass "pass:$keyPass" --allowResign

    - name: Find signed APK
      id: find_signed
      shell: pwsh
      run: |
        $signedPath = "${{ steps.find_apks.outputs.apk_path }}".Replace(".apk", "-Signed.apk")
        Write-Host "Signed APK location: $signedPath"
        "signed_path=$signedPath" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: android-build-${{ github.run_number }}
        name: Android build ${{ github.run_number }}
        body: |
          Automated Android build for osu! lazer with custom server support.

          **Build Details:**
          - Commit: ${{ github.sha }}
          - Branch: ${{ github.ref }}
          - Run: ${{ github.run_id }}

          This build includes custom server configuration for osu!droid-rx compatibility.
        draft: true
        prerelease: false
        files: |
          ${{ steps.find_signed.outputs.signed_path }}
        fail_on_unmatched_files: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
